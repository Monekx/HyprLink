package config

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"gopkg.in/yaml.v3"
)

type ConfigBundle struct {
	UI      UIConfig
	Actions map[string]string
}

func BuildFullConfig(configDir string) (*ConfigBundle, error) {
	mainData, err := os.ReadFile(filepath.Join(configDir, "main.yaml"))
	if err != nil {
		mainData, err = os.ReadFile(filepath.Join(configDir, "main.json"))
		if err != nil {
			return nil, err
		}
	}

	var main MainConfig
	if err := yaml.Unmarshal(mainData, &main); err != nil {
		return nil, err
	}

	actions := make(map[string]string)

	var ui UIConfig
	ui.Hostname = main.Hostname
	ui.Profiles = []Tab{}

	for _, prof := range main.Profiles {
		loadedProf, err := resolveProfile(configDir, prof)
		if err != nil {
			continue
		}

		tab := Tab{Name: loadedProf.Name, Modules: []Module{}}
		for _, mod := range loadedProf.Modules {
			resolvedMod, err := resolveModule(configDir, mod, actions)
			if err != nil {
				continue
			}
			tab.Modules = append(tab.Modules, resolvedMod)
		}
		ui.Profiles = append(ui.Profiles, tab)
	}

	cssData, _ := os.ReadFile(filepath.Join(configDir, "style.css"))
	ui.CSS = string(cssData)

	hashData, _ := json.Marshal(ui)
	ui.Hash = fmt.Sprintf("%x", md5.Sum(hashData))

	actions["_note"] = "AUTOGENERATED FROM WIDGET CONFIGS. DO NOT EDIT."
	actionsPath := filepath.Join(configDir, "actions.yaml")
	actionsData, _ := yaml.Marshal(actions)
	os.WriteFile(actionsPath, actionsData, 0644)

	return &ConfigBundle{UI: ui, Actions: actions}, nil
}

func resolveProfile(baseDir string, p Profile) (Profile, error) {
	if p.Import != "" {
		path := filepath.Join(baseDir, p.Import)
		data, err := os.ReadFile(path)
		if err != nil {
			return Profile{}, err
		}
		var loaded Profile
		if err := yaml.Unmarshal(data, &loaded); err != nil {
			return Profile{}, err
		}

		if p.Name != "" {
			loaded.Name = p.Name
		}
		return loaded, nil
	}
	return p, nil
}

func resolveModule(baseDir string, m Module, actions map[string]string) (Module, error) {
	if m.Import != "" {
		path := filepath.Join(baseDir, m.Import)
		data, err := os.ReadFile(path)
		if err != nil {
			return Module{}, err
		}
		var loaded Module
		if err := yaml.Unmarshal(data, &loaded); err != nil {
			return Module{}, err
		}

		if m.ID != "" {
			loaded.ID = m.ID
		}
		if m.Type != "" {
			loaded.Type = m.Type
		}
		if m.Label != "" {
			loaded.Label = m.Label
		}
		if m.View != "" {
			loaded.View = m.View
		}
		if m.Icon != "" {
			loaded.Icon = m.Icon
		}
		if m.ConfigAction != "" {
			loaded.ConfigAction = m.ConfigAction
		}
		if m.Source != "" {
			loaded.Source = m.Source
		}
		if len(m.Children) > 0 {
			loaded.Children = m.Children
		}

		return resolveModule(baseDir, loaded, actions)
	}

	if m.ConfigAction != "" {
		var actionKey string
		if m.ID != "" {
			actionKey = m.ID
		} else {
			actionKey = fmt.Sprintf("cmd_%x", md5.Sum([]byte(m.ConfigAction)))
			m.ID = actionKey
		}
		actions[actionKey] = m.ConfigAction
		m.Action = actionKey
	}

	if len(m.Children) > 0 {
		var resolvedChildren []Module
		for _, child := range m.Children {
			res, err := resolveModule(baseDir, child, actions)
			if err != nil {
				return Module{}, err
			}
			resolvedChildren = append(resolvedChildren, res)
		}
		m.Children = resolvedChildren
	}

	if m.ID == "" {
		m.ID = "auto_" + GenerateToken()
	}

	return m, nil
}
